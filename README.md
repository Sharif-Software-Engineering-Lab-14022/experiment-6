# experiment-6
It's the sixth experiment of Software Engineering Lab course in Spring 2024 at Sharif University of Technology.

## Members
| Name                  | Student Number |
| --------------------- | --------       |
| Amir Mohammad Fakhimi | 99170531       |
| Mohammad Amin Lotfi   | 98171075       |
| Mana Peyravian        | 98170721       |

# مقدمه
هدف از این آزمایش، پیاده‌سازی یک سیستم مدیریت حمل و نقل با استفاده از الگوهای طراحی State و Strategy در جاوا بود. این سیستم انتقال بسته ها را در state های مختلف (In Transit یا Delivered) مدیریت می کند و به کاربران این امکان را می دهد که strategy های حمل و نقل مختلف (Standard یا Express) را انتخاب کنند.

# شرح آزمایش

### پیاده سازی الگوی State:
این الگو برای نشان دادن حالات مختلف یک بسته یعنی In Transit یا Delivered به عنوان کلاس هایی که یک interface مشترک (PackageState) را پیاده سازی می کنند، استفاده شده. کلاس PackageContext یک ارجاع به state فعلی را حفظ می کند و می تواند بر اساس شرایط خاصی بین state ها جابجا شود.

### پیاده سازی الگوی Strategy:
این الگو برای encapsulate کردن استراتژی های حمل و نقل مختلف (ShippingStrategy) استفاده شده است. رابط ShippingStrategy و پیاده‌سازی‌های آن (StandardShippingStrategy، ExpressShippingStrategy) نحوه محاسبه حمل و نقل مختلفی را نشان می‌دهند که به صورت پویا می‌توان آنها را تغییر داد.

#### در کل پیاده سازی شامل چندین کلاس و رابط است:

کلاس PackageContext: این کلاس context یک بسته را نشان می دهد و state و strategy حمل و نقل آن را مدیریت می کند. این شامل متد هایی برای به روز رسانی state بسته و محاسبه هزینه حمل و نقل است.

رابط PackageState: این رابط متد هایی را برای دریافت state یک بسته و به روز رسانی state آن تعریف می کند.

کلاس های InTransitState و DeliveredState: این کلاس‌ها رابط PackageState را پیاده‌سازی می‌کنند و حالت‌های یک بسته را نشان می‌دهند: InTransit و Delivered.

رابط ShippingStrategy: این رابط متدی را برای محاسبه هزینه حمل و نقل بر اساس وزن بسته تعریف می کند.

کلاس های StandardShippingStrategy و ExpressShippingStrategy: این کلاس ها رابط ShippingStrategy را پیاده سازی می کنند و روش های مختلفی را برای محاسبه قیمت حمل و نقل ارائه می کنند.

کلاس Main:
کلاس Main به عنوان نقطه ورودی برنامه عمل می کند. از کاربر می خواهد که وزن بسته را وارد کرده و یک روش حمل و نقل (Standard یا Express) را انتخاب کند. سپس هزینه حمل و نقل را بر اساس روش انتخابی محاسبه می کند و از کاربر می خواهد که روش ارسال را تغییر دهد یا بسته را به عنوان Delivered انتخاب کند. برنامه تا زمانی ادامه می یابد که بسته به عنوان Delivered علامت گذاری شود.

برای پیاده سازی نیز از روش TDD استفاده شده است و تست ها در فایل PackageContextTest.java قرار دارند.

## پرسش‌ها
### سوال ۱
#### در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.
۱. الگوهای ایجادی (Creational): این الگوها با مکانیزم ایجاد شیء سروکار دارند، معمولاً برای به حداقل رساندن وابستگی بین آنها و انتزاع روند دستی ایجاد شیء استفاده می‌شوند، که آن را انعطاف‌پذیرتر می‌کند. این الگو‌ها بر فرآیند ایجاد شیء در توسعه نرم‌افزار متمرکز هستند، اطمینان حاصل می‌کنند که چیزها را به شیوه‌ای ایجاد می‌کنیم که نه تنها ساده بلکه انعطاف‌پذیر نیز هست، به‌طوری که اگر بعداً نیاز داشتیم بتوانیم آنها را تغییر دهیم.

۲. الگوهای ساختاری (Structural): هدف اصلی این الگوها دستیابی به ترکیب شیء است، به طور موثر وابستگی‌های شدید اشیاء و روابط بین آنها را در سراسر بخش‌های مختلف برنامه نرم‌افزاری مدیریت می‌کند. این الگو‌ها راهی برای ایجاد رابطه بین اشیاء فراهم می‌کنند، مانند استفاده از ارث‌بری یا ترکیب برای ایجاد اشیاء از سایر اشیاء، یا ارائه راهی برای دسترسی به عناصر یک شیء، بدون در معرض نمایش قرار دادن ساختار کلی آن.

۳. الگوهای رفتاری (Behavioral): این الگوها به چگونگی تعامل اشیاء و همکاری آنها با یکدیگر برای دستیابی به یک عملکرد خاص مربوط هستند. این الگو‌ها تعریف می‌کنند که اشیاء چگونه با یکدیگر تعامل می‌کنند و چگونه مسئولیت‌ها را بین اشیاء توزیع می‌کنند، مانند تعریف اینکه یک شیء چگونه باید به تغییرات در وضعیت خود واکنش نشان دهد یا چگونه باید به درخواست از شیء دیگر پاسخ دهد.

### سوال ۲
#### الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟
الگوهای State و Strategy هر دو در دسته الگوهای طراحی رفتاری (Behavioral) قرار می‌گیرند.
الگوهای طراحی رفتاری مربوط به الگوریتم‌ها و تخصیص مسئولیت‌ها بین اشیاء هستند. آنها بر بهبود یا ساده‌سازی ارتباط بین اشیاء متفاوت در یک سیستم تمرکز دارند.
الگوهای State و Strategy از نظر ساختار شبیه به هم هستند، زیرا هر دو بر اساس ترکیب و تفویض کار به سایر اشیاء بنا شده‌اند. با این حال، آنها مسائل متفاوتی را حل می‌کنند:
الگوی Strategy یک مجموعه از الگوریتم‌های مرتبط را کپسوله می‌کند و به کاربر اجازه می‌دهد تا از رفتارهای قابل تعویض از طریق ترکیب و تفویض در زمان اجرا استفاده کند. این الگو بخش "چگونگی" یک شیء را تعریف می‌کند.
الگوی State به یک شیء کمک می‌کند تا در وضعیت‌های مختلف، رفتارهای متفاوتی از خود نشان دهد. این الگو بخش‌های "چه" و "کی" یک شیء را تعریف می‌کند. وضعیت بخشی از خود شیء زمینه است و با گذشت زمان، شیء زمینه از یک وضعیت به وضعیت دیگر منتقل می‌شود.

### سوال ۳
#### با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.
الگوی طراحی مناسب برای ایجاد این سیستم، الگوی طراحی Strategy است. این به این دلیل است که سیستم شامل چندین الگوریتم برای محاسبه قیمت یک بسته بر اساس وزن و روش ارسال آن است و امکان جابجایی پویا بین این الگوریتم‌ها در زمان اجرا وجود دارد.

الگوی Strategy به ما امکان می‌دهد تا هر الگوریتم را در یک کلاس جداگانه به نام استراتژی کپسوله کنیم که یک رابط خاص را پیاده می‌کند. این رابط، متدهای مشترکی را که همه استراتژی‌ها باید پیاده کنند، مانند محاسبه قیمت بسته را تعریف می‌کند. کلاس زمینه که نماینده بسته است، یک مرجع به یک شیء استراتژی را نگه می‌دارد و محاسبه قیمت را به آن تفویض می‌کند. به این ترتیب، کلاس زمینه از جزئیات پیاده‌سازی خاص الگوریتم‌ها جدا می‌شود و می‌تواند به راحتی در زمان اجرا بین استراتژی‌های مختلف جابجا شود.

در این مورد، ما دو کلاس استراتژی مشخص برای روش ارسال استاندارد و روش ارسال سریع خواهیم داشت. هر یک از این کلاس‌ها رابط استراتژی را پیاده می‌کنند و پیاده‌سازی خاص خود را برای متد محاسبه قیمت ارائه می‌دهند. کلاس زمینه سپس از این استراتژی‌ها برای محاسبه قیمت بسته بر اساس روش ارسال انتخاب شده استفاده می‌کند.

الگوی State نیز می‌تواند در این سیستم استفاده شود، به ویژه برای مدیریت تغییرات وضعیت بسته هنگامی که از یک وضعیت به وضعیت دیگر (مثلاً از در حال انتقال به تحویل داده شده) منتقل می‌شود. با این حال، تمرکز اصلی الگوی State بر مدیریت تغییرات وضعیت و کپسوله کردن رفتار خاص وضعیت است، در حالی که الگوی Strategy بیشتر بر کپسوله کردن الگوریتم‌ها و امکان جابجایی پویا بین آنها متمرکز است.

```java
// Strategy interface
interface ShippingStrategy {
    double calculatePrice(double weight);
}

// Concrete strategies
class StandardShippingStrategy implements ShippingStrategy {
    @Override
    public double calculatePrice(double weight) {
        return weight * 2.5;
    }
}

class ExpressShippingStrategy implements ShippingStrategy {
    @Override
    public double calculatePrice(double weight) {
        return weight * 3.5;
    }
}

// Context class
class Package {
    private double weight;
    private ShippingStrategy strategy;

    public Package(double weight, ShippingStrategy strategy) {
        this.weight = weight;
        this.strategy = strategy;
    }

    public void setShippingStrategy(ShippingStrategy strategy) {
        this.strategy = strategy;
    }

    public double calculatePrice() {
        return strategy.calculatePrice(weight);
    }
}

// Example usage
public class Main {
    public static void main(String[] args) {
        Package package1 = new Package(10.0, new StandardShippingStrategy());
        System.out.println("Price for standard shipping: " + package1.calculatePrice());

        package1.setShippingStrategy(new ExpressShippingStrategy());
        System.out.println("Price for express shipping: " + package1.calculatePrice());
    }
}
```
در مثال فوق، کلاس `Package` زمینه را نشان می‌دهد و ارجاع به یک شی `ShippingStrategy` را حفظ می‌کند. رابط `ShippingStrategy` متد محاسبه قیمت را تعریف می‌کند که توسط کلاس‌های `StandardShippingStrategy` و `ExpressShippingStrategy` پیاده‌سازی می‌شود. کلاس `Package` از استراتژی انتخاب شده برای محاسبه قیمت بسته بر اساس وزن آن استفاده می کند.

### سوال ۴
#### تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).
**اصل SRP:** الگوی Singleton اصل SRP را برآورده نمی‌کند زیرا دو مسئولیت اطمینان از وجود یک نمونه تک و ارائه یک نقطه دسترسی جهانی (Global Access Point) را ترکیب می‌کند. این می‌تواند منجر به یک کلاس شود که مسئول چندین وظیفه است، که این مغایر با این اصل است. این کلاس هم مسئول مدیریت نمونه (instance) و هم ارائه دسترسی به آن است که باعث کاهش قابلیت نگهداری و افزایش پیچیدگی می‌شود.

**اصل OCP:** الگوی Singleton اصل OCP را برآورده نمی‌کند زیرا برای گسترش باز نیست بلکه برای تغییر بسته است. زمانی که کلاس Singleton پیاده‌سازی شد، تغییر رفتار یا گسترش کارکرد آن بدون تغییر در پیاده‌سازی زیری دشوار است. این باعث می‌شود که کمتر انعطاف‌پذیر و کمتر قابل انطباق با نیازهای در حال تغییر باشد.

**اصل LSP:** الگوی Singleton اصل LSP را برآورده می‌کند زیرا از استفاده کلاس‌های مشتق به عنوان کلاس‌های پایه جلوگیری نمی‌کند. کلاس Singleton می‌تواند به عنوان یک کلاس پایه برای سایر کلاس‌ها استفاده شود بدون اینکه بر عملکرد یا رفتار کلاس‌های مشتق تأثیر بگذارد.

**اصل ISP:** الگوی Singleton به طور مستقیم به اصل ISP مربوط نمی‌شود زیرا در درجه اول مربوط به اطمینان از وجود یک نمونه تک از یک کلاس است نه تعریف رابط‌ها. با این حال، اصل ISP می‌تواند در الگوی Singleton با تعریف رابط‌هایی برای کلاس Singleton و مشتریان آن اعمال شود که انعطاف‌پذیری بیشتری را فراهم می‌کند.

**اصل DIP:** الگوی Singleton اصل DIP را برآورده نمی‌کند زیرا وابستگی‌ها بین کلاس‌ها را معکوس نمی‌کند. کلاس Singleton مسئول مدیریت نمونه خود و ارائه دسترسی به آن است که باعث ایجاد یک وابستگی تنگاتنگ بین کلاس Singleton و مشتریان آن می‌شود. این امر، تغییر یا جایگزینی کلاس Singleton را بدون تأثیر بر مشتریانی که به آن وابسته هستند، دشوار می‌کند.
